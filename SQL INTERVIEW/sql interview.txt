
1) What is SQL?
SQL (Structured Query Language) is a programming language used to manage and manipulate relational databases. 
 It allows users to create,read,update, and delete data — commonly referred to as CRUD operations

Example:
sql
SELECT name FROM students WHERE grade > 90;
This retrieves names of students whose grade is above 90.

2) How SQL Works
SQL works by sending queries to a Database Management System (DBMS). The DBMS interprets the query, optimizes it,
 and executes it to fetch or modify data.

Execution Flow:
1. Parsing – Checks syntax.
2. Optimization – Chooses the best way to run the query.
3. Execution – Retrieves or modifies data.
4. Return – Sends results back to the user.

3) Why SQL is Important
- It’s the standard language for relational databases.
- Used in data analysis, web development,reporting, and business intelligence.
- Powers backend systems of apps like Instagram, LinkedIn, and banking platforms.

4) Why Should We Use SQL?
- Universal: Works across many database systems (MySQL, SQL Server, PostgreSQL).
- Efficient: Handles large datasets quickly.
- Readable: Easy to learn and write.
- Secure: Supports permissions and access control.

5) How the Query Runs in Backend
When you run a query:
1. SQL Engine receives it.
2. Parser checks syntax.
3. Algebrizer validates tables/columns.
4. Optimizer picks the best execution plan.
5. Execution Engine runs the plan.
6. Storage Engine fetches data from disk.
7. Results are returned to the user.

6) What Work Occurs in Backend While Running SQL Query
- Syntax check** (Parsing)
- **Semantic check** (Binding)
- **Query optimization**
- **Index lookup**
- **Disk I/O operations**
- **Memory allocation**
- **Concurrency control**
- **Transaction logging**
- **Result formatting**

7) What is SQL Server Architecture?
SQL Server has a **client-server architecture** with three main layers:
1. **Protocol Layer** – Handles communication.
2. **Relational Engine** – Parses, compiles, and optimizes queries.
3. **Storage Engine** – Manages data storage, indexes, and transactions.

End-to-End Workflow

1. *Client sends query* via SSMS or app.
2. *Protocol Layer* receives and formats it.
3. *Relational Engine* parses and plans execution.
4. *Storage Engine* fetches or updates data.
5. *Results returned* to client.

8) What is MS SQL Server Architecture?
Same as above but specific to Microsoft SQL Server:
- **TDS Protocol** – Communicates with clients.
- **SQL OS (SQLOS)** – Manages threads, memory, and I/O.
- **Query Processor** – Parses and optimizes queries.
- **Access Methods** – Interfaces with storage.
- **Buffer Manager** – Caches data pages.
- **Transaction Manager** – Ensures ACID compliance.

9) What is Cloud Computing?
Cloud computing is the delivery of computing services (servers, storage, databases, networking, software) over the internet.

**Types:**
- **IaaS** – Infrastructure as a Service
- **PaaS** – Platform as a Service
- **SaaS** – Software as a Service

10) What is Index?
An **index** is a data structure that improves the speed of data retrieval operations on a database table.

**Example:**
```sql
CREATE INDEX idx_name ON students(name);
```
11) How Index Works
- Indexes store a **sorted reference** to data.
- When a query runs, the DBMS uses the index to **quickly locate** rows instead of scanning the entire table.
- Works like a book’s table of contents.

12) Use of Index
- Faster queries
- Efficient sorting
- Improved JOIN performance
- Reduced CPU and I/O usage

13) Differences Between Cloud Computing and On-Premises
| Feature              | Cloud Computing         | On-Premises              |
|----------------------|-------------------------|--------------------------|
| Deployment           | Internet-based          | Local servers            |
| Cost                 | Pay-as-you-go           | Upfront hardware cost    |
| Scalability          | High                    | Limited                  |
| Maintenance          | Vendor-managed          | User-managed             |
| Accessibility        | Global                  | Local network only       |


14) What is Parse in SQL?
Parsing is the process of analyzing a SQL query to check its syntax and structure before execution.

15) Work of Parse
- Tokenization – Breaks query into parts.
- Syntax Validation – Checks grammar.
- Tree Generation – Builds parse tree.
- Error Reporting – Flags mistakes.

16) Importance of Parse
- Prevents invalid queries from executing.
- Ensures query is well-formed.
- First step in query optimization.

17) What is SQL DSA?
SQL DSA (Data Services Architecture)** refers to the architectural model used in enterprise systems to manage data services —
 including integration, transformation, and access — often in cloud or hybrid environments.

It’s not a standard SQL feature but a concept used in platforms like SAP or Oracle for **data abstraction and orchestration**.

18)Why Normalize?
- ✅ Eliminate redundant data (e.g., storing the same customer info in multiple places)
- ✅ Ensure data dependencies make sense
- ✅ Improve consistency and reduce anomalies during insert, update, or delete operations

19)Forms of Normalization
Each "normal form" builds on the previous one. Here are the most common ones:

| Normal Form                     | Description                                           | Key Rule |

| *1NF (First Normal Form)*       | Ensures each column holds atomic (indivisible) values | No repeating groups or arrays |
| *2NF (Second Normal Form)*      | Builds on 1NF and removes partial dependencies        | Every non-key column must depend on the whole primary key |
| *3NF (Third Normal Form)*       | Builds on 2NF and removes transitive dependencies     | Non-key columns must depend only on the primary key |
| *BCNF (Boyce-Codd Normal Form)* | A stricter version of 3NF                             | Every determinant must be a candidate key |

20)Example: From Unnormalized to 3NF

Unnormalized Table
sql
-- Student table with repeating subjects
Student(ID, Name, Subject1, Subject2, Subject3)

1NF
sql
-- Break into atomic rows
Student(ID, Name)
Enrollment(ID, Subject)

2NF
sql
-- Remove partial dependency (if ID is composite)
-- Assume Enrollment(ID, Subject) is the primary key
-- Move subject details to a separate table
Subject(SubjectID, SubjectName)
Enrollment(StudentID, SubjectID)

3NF
sql
-- Remove transitive dependency
-- If SubjectName depends on SubjectID, and SubjectID is not a key in Enrollment
-- Keep Subject details separate

21)Groups (Repeating Groups)
- *Meaning*: When a table has multiple columns for the same type of data.
- *Example*:
  sql
  Student(ID, Name, Subject1, Subject2, Subject3)
  This is a repeating group of subjects. It violates *1NF* because each subject should be in a separate row, not separate columns.

CustomerId   |Name     |Phone1     |Phone2
101           Alice     123-4567    987-6543

Create a seprate table for phone numbers:
CustomerId     |Phone
101             123-4567
101             987-6543

22)Arrays
- *Meaning*: When a column stores multiple values in a single field (like a list or array).
- *Example*:
  sql
  Student(ID, Name, Subjects = ['Math', 'Science', 'English'])
  
  This also violates *1NF* because SQL expects atomic (single) values per cell.

23)Redundancy
- *Meaning*: Storing the same data in multiple places unnecessarily.
- *Example*:
  sql
  Order(ID, CustomerName, CustomerAddress, CustomerPhone)
 If the same customer places multiple orders, their info is repeated. Better to store customer details in a separate table.

orderid  |  customername    |customeraddress    |product
1           Alice            NY                  Laptop
2           Alice            NY                  Mouse
Here,CustomerName and CustomerAddress repeat for every order.


24)Anomalies
These are problems that occur due to poor database design:

| Type             | Description |

| *Insert Anomaly* | Can't add data because other required data is missing |
| *Update Anomaly* | Updating one record requires updating many others |
| *Delete Anomaly* | Deleting one record unintentionally removes valuable data |

*Example*: If you delete the last order of a customer, you might lose their contact info too.

25) Partial Dependency
- *Meaning*: A non-key column depends only on part of a composite primary key.
- *Example*:
  sql
  Table: Enrollment(StudentID, CourseID, StudentName)
  
  Here, StudentName depends only on StudentID, not the full key (StudentID + CourseID). This violates *2NF*.

26)Transitive Dependency
- *Meaning*: A non-key column depends on another non-key column, which depends on the primary key.
- *Example*:
  sql
  Employee(ID, DeptID, DeptName)
  
  DeptName depends on DeptID, which depends on ID. This violates *3NF*.

27)Candidate Key
- *Meaning*: A column (or set of columns) that can uniquely identify a row.
- *Example*:
  In a Student table:
  - StudentID is a candidate key
  - If Email is unique, it’s also a candidate key
  - The *Primary Key* is chosen from the candidate keys

28)Triggers & Views
- Automate actions with AFTER and INSTEAD OF triggers.
- Use views to simplify complex joins or enforce security.
- Learn when triggers are helpful — and when they’re a performance trap.

29)Backup & Restore
- Learn how to protect your data from disasters.
- Explore full, differential, and transaction log backups.
- Master restoring databases with precision — even point-in-time recovery.

30)Stored Procedures & Functions
- Encapsulate logic for reuse and security.
- Compare scalar vs. table-valued functions.
- Understand parameter handling and output values.

31)Steps
Download SQL Server From Microsoft’s official site

 step1:  Run Installer Choose Basic or Custom setup.
 step2:  Accept License Terms
 step3:  Select Features Choose components like Database Engine, SSMS, etc.
 step4:  Configure Instance Name
 step5:  Set Authentication Mode
 step6:  Windows Authentication (default)
 step7:  Mixed Mode (SQL + Windows)
 step8:  Specify Admin Account
 step9:  Install SSMS (Optional) For GUI-based management.[Graphical user interface]








